use std::{env, fs, path::PathBuf};

fn main() {
    // Set CMAKE_GENERATOR to Ninja for SDL3 build
    println!("cargo:rustc-env=CMAKE_GENERATOR=Ninja");

    generate_viiper_metadata();
    fetch_viiper_binary();

    #[cfg(windows)]
    {
        let mut res = winres::WindowsResource::new();

        res.set_icon("assets/icon.ico");

        let version = option_env!("SISR_VERSION")
            .or(option_env!("CARGO_PKG_VERSION"))
            .unwrap_or("0.0.1");

        let version_clean = version.strip_prefix('v').unwrap_or(version);

        let version_parts: Vec<&str> = version_clean
            .split('-')
            .next()
            .unwrap_or(version_clean)
            .split('.')
            .collect();
        let major = version_parts
            .get(0)
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(0);
        let minor = version_parts
            .get(1)
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(0);
        let patch = version_parts
            .get(2)
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(0);

        res.set_version_info(
            winres::VersionInfo::PRODUCTVERSION,
            (major << 48) | (minor << 32) | (patch << 16),
        );
        res.set_version_info(
            winres::VersionInfo::FILEVERSION,
            (major << 48) | (minor << 32) | (patch << 16),
        );

        res.set("FileVersion", &format!("{}.{}.{}.0", major, minor, patch));
        res.set("ProductVersion", version_clean);
        res.set("ProductName", "SISR");
        res.set("FileDescription", "SISR - Steam Input System Redirector");
        res.set("CompanyName", "Peter Repukat");
        res.set(
            "LegalCopyright",
            "Copyright (C) 2025 Peter Repukat - GPL-3.0",
        );
        res.set("OriginalFilename", "SISR.exe");
        res.set("InternalName", "sisr");

        let manifest = format!(
            r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity
    version="{}.{}.{}.0"
    publicKeyToken="0000000000000000"
    name="SISR"
    type="win32"
  />
  <description>SISR - Steam Input System Redirector</description>
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
</assembly>
"#,
            major, minor, patch
        );

        res.set_manifest(&manifest);

        if let Err(e) = res.compile() {
            eprintln!("Warning: Failed to compile Windows resources: {}", e);
        }
    }

    println!("cargo:rerun-if-env-changed=SISR_VERSION");
    println!("cargo:rerun-if-changed=Cargo.toml");
    println!("cargo:rerun-if-changed=assets/icon.ico");
}

fn generate_viiper_metadata() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let cargo_toml_path = manifest_dir.join("Cargo.toml");

    let cargo_toml = fs::read_to_string(&cargo_toml_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {e}", cargo_toml_path.display()));

    let doc: toml::Table = cargo_toml
        .parse()
        .unwrap_or_else(|e| panic!("Failed to parse {} as TOML: {e}", cargo_toml_path.display()));

    let viiper = doc
        .get("package")
        .and_then(|v| v.get("metadata"))
        .and_then(|v| v.get("viiper"));

    let min_version = viiper
        .and_then(|v| v.get("viiper-version"))
        .and_then(|v| v.as_str())
        .unwrap_or("0.0.0");

    let allow_dev = viiper
        .and_then(|v| v.get("allow_dev"))
        .and_then(|v| v.as_bool())
        .unwrap_or(false);

    let fetch_prelease = viiper
        .and_then(|v| v.get("fetch_prelease"))
        .and_then(|v| v.as_bool())
        .unwrap_or(false);

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let out_path = out_dir.join("viiper_metadata.rs");

    let generated = format!(
        "// @generated by build.rs; do not edit by hand.\n\n\
pub const VIIPER_MIN_VERSION: &str = {min_version:?};\n\
pub const VIIPER_ALLOW_DEV: bool = {allow_dev};\n\
pub const VIIPER_FETCH_PRELEASE: bool = {fetch_prelease};\n",
    );

    fs::write(&out_path, generated)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", out_path.display()));

    println!("cargo:rerun-if-changed={}", cargo_toml_path.display());
}

fn fetch_viiper_binary() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let cargo_toml_path = manifest_dir.join("Cargo.toml");
    let cargo_toml = fs::read_to_string(&cargo_toml_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {e}", cargo_toml_path.display()));
    let doc: toml::Table = cargo_toml
        .parse()
        .unwrap_or_else(|e| panic!("Failed to parse {} as TOML: {e}", cargo_toml_path.display()));

    let viiper = doc
        .get("package")
        .and_then(|v| v.get("metadata"))
        .and_then(|v| v.get("viiper"));

    let fetch_prelease = viiper
        .and_then(|v| v.get("fetch_prelease"))
        .and_then(|v| v.as_bool())
        .unwrap_or(false);

    if !fetch_prelease {
        return;
    }

    let min_version = viiper
        .and_then(|v| v.get("viiper-version"))
        .and_then(|v| v.as_str())
        .unwrap_or("0.0.0")
        .trim();

    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_else(|_| "unknown".into());
    let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_else(|_| "unknown".into());

    let is_windows = target_os == "windows";
    let asset_name = match (target_os.as_str(), target_arch.as_str()) {
        ("windows", "x86_64") => "viiper-windows-amd64.exe",
        ("windows", "aarch64") => "viiper-windows-arm64.exe",
        ("linux", "x86_64") => "viiper-linux-amd64",
        ("linux", "aarch64") => "viiper-linux-arm64",
        _ => {
            eprintln!(
                "Warning: VIIPER fetch_prelease enabled but unsupported target: os={target_os} arch={target_arch}"
            );
            return;
        }
    };

    let requested_tag = if min_version.starts_with('v') {
        min_version.to_string()
    } else {
        format!("v{min_version}")
    };

    let release = github_release_by_tag_or_fallback(&requested_tag);
    let tag_name = release
        .get("tag_name")
        .and_then(|v| v.as_str())
        .unwrap_or("<unknown>");

    let url = release
        .get("assets")
        .and_then(|a| a.as_array())
        .and_then(|assets| {
            assets
                .iter()
                .find(|a| a.get("name").and_then(|n| n.as_str()) == Some(asset_name))
        })
        .and_then(|a| a.get("browser_download_url"))
        .and_then(|u| u.as_str())
        .unwrap_or_else(|| {
            panic!("VIIPER release '{tag_name}' does not contain expected asset '{asset_name}'.")
        });

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let cache_dir = out_dir.join("viiper");
    let _ = fs::create_dir_all(&cache_dir);

    let downloaded_path = cache_dir.join(asset_name);
    let version_marker = cache_dir.join(format!("{}.marker", sanitize_filename(tag_name)));
    if downloaded_path.exists() && version_marker.exists() {
        // Cached.
    } else {
        for entry in fs::read_dir(&cache_dir)
            .unwrap_or_else(|_| fs::read_dir(&out_dir).unwrap())
            .flatten()
        {
            let p = entry.path();
            if p.extension().and_then(|e| e.to_str()) == Some("marker") {
                let _ = fs::remove_file(p);
            }
        }

        download_to_file(url, &downloaded_path);
        let _ = fs::write(&version_marker, tag_name);

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&downloaded_path)
                .expect("downloaded file metadata")
                .permissions();
            perms.set_mode(0o755);
            let _ = fs::set_permissions(&downloaded_path, perms);
        }
    }

    let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".into());
    let target_dir = env::var("CARGO_TARGET_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| manifest_dir.join("target"));
    let bin_dir = target_dir.join(&profile);
    let _ = fs::create_dir_all(&bin_dir);
    let dest_path = bin_dir.join(if is_windows { "viiper.exe" } else { "viiper" });
    fs::copy(&downloaded_path, &dest_path)
        .unwrap_or_else(|e| panic!("Failed to copy VIIPER to {}: {e}", dest_path.display()));

    println!(
        "cargo:warning=VIIPER fetched: tag={} asset={} -> {}",
        tag_name,
        asset_name,
        dest_path.display()
    );
}

fn github_release_by_tag_or_fallback(requested_tag: &str) -> serde_json::Value {
    let tag_url = format!(
        "https://api.github.com/repos/Alia5/VIIPER/releases/tags/{}",
        requested_tag
    );
    match github_get_json(&tag_url) {
        Ok(v) => return v,
        Err(ureq::Error::StatusCode(404)) => {}
        Err(e) => {
            panic!("Failed to fetch VIIPER release by tag '{requested_tag}': {e}");
        }
    }

    let list_url = "https://api.github.com/repos/Alia5/VIIPER/releases";
    let releases = github_get_json(list_url)
        .unwrap_or_else(|e| panic!("Failed to fetch VIIPER releases list: {e}"));
    let arr = releases
        .as_array()
        .unwrap_or_else(|| panic!("Unexpected VIIPER releases response (not an array)"));

    let mut newest_prerelease: Option<serde_json::Value> = None;
    let mut newest_stable: Option<serde_json::Value> = None;

    for r in arr {
        let prerelease = r
            .get("prerelease")
            .and_then(|p| p.as_bool())
            .unwrap_or(false);
        if prerelease && newest_prerelease.is_none() {
            newest_prerelease = Some(r.clone());
        }
        if !prerelease && newest_stable.is_none() {
            newest_stable = Some(r.clone());
        }
        if newest_prerelease.is_some() && newest_stable.is_some() {
            break;
        }
    }

    newest_prerelease
        .or(newest_stable)
        .unwrap_or_else(|| panic!("No VIIPER releases found"))
}

fn github_get_json(url: &str) -> Result<serde_json::Value, ureq::Error> {
    let mut resp = ureq::get(url)
        .header("User-Agent", "SISR-build-script")
        .header("Accept", "application/vnd.github+json")
        .call()?;

    resp.body_mut().read_json::<serde_json::Value>()
}

fn download_to_file(url: &str, path: &PathBuf) {
    let mut resp = ureq::get(url)
        .header("User-Agent", "SISR-build-script")
        .call()
        .unwrap_or_else(|e| panic!("Failed to download {url}: {e}"));

    let mut reader = resp.body_mut().as_reader();
    let mut out = fs::File::create(path)
        .unwrap_or_else(|e| panic!("Failed to create {}: {e}", path.display()));
    std::io::copy(&mut reader, &mut out)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", path.display()));
}

fn sanitize_filename(s: &str) -> String {
    s.chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '-' || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}
